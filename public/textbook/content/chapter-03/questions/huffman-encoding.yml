id: "ch3-huffman-encoding"
type: "short-answer"
chapter: 3
question: |
  **Implement Huffman encoding for data compression.**
  
  **Level 0** Discuss why Huffman encoding is significant for data compression and where it's used.
  
  **Level 1** For sample character frequencies, demonstrate Huffman tree construction. Give pseudocode.
  
  **Level 2** Implement Huffman encoding in a language of your choice.
  
  **Level 3** Prove why the greedy algorithm produces an optimal prefix-free code. Analyze the compression ratio.

answer: |
  **Huffman Algorithm:**
  Build min-heap of characters by frequency. Repeatedly extract two minimum nodes, create parent with sum of frequencies, re-insert. Assign 0/1 to edges. Frequent characters get shorter codes.
  
  **Why optimal:**
  Greedy choice (combine lowest frequencies) ensures high-frequency characters near root. Exchange argument proves no better prefix code exists for given frequencies.
  
  **Applications:**
  ZIP compression, JPEG (variants), MP3, used whenever statistical compression needed.
  
  **Time complexity:** O(n log n) with heap.

topics:
  - "Huffman Encoding"
  - "Greedy Algorithms"
  - "Data Compression"
