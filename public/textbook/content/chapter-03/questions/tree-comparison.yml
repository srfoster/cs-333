id: "ch3-tree-comparison"
type: "short-answer"
chapter: 3
question: |
  Compare and contrast Binary Search Trees (BSTs), AVL Trees, Red-Black Trees, and B-Trees by addressing the following:
  
  (a) Describe the defining property or invariant that each tree type maintains.
  
  (b) Explain the balancing mechanism (if any) for each tree type.
  
  (c) Compare their height guarantees and how this affects lookup performance.
  
  (d) Discuss the insertion/deletion cost trade-offs between these tree types.
  
  (e) Identify real-world use cases where each tree type is most appropriate.
answer: |
  (a) Defining properties:
     - BST: For every node, all values in left subtree < node < all values in right subtree. No balancing guarantee.
     - AVL: BST + balance factor constraint: |height(left) - height(right)| ≤ 1 for every node.
     - Red-Black: BST + color properties: nodes are red/black, root is black, red nodes have black children, all paths from root to leaves have same number of black nodes.
     - B-Tree: Multi-way search tree where each node can hold multiple keys (minimum degree t means 1 to 2t-1 keys per node). All leaves at same level.
  
  (b) Balancing mechanisms:
     - BST: None - can degrade to linked list (O(n) height) in worst case.
     - AVL: Tree rotations (single and double) triggered when balance factor exceeds ±1 during insertion/deletion.
     - Red-Black: Combination of recoloring and rotations (fewer rotations than AVL due to looser constraints).
     - B-Tree: Node splits and merges during insertion/deletion, promoting/demoting keys between levels.
  
  (c) Height guarantees:
     - BST: O(n) worst case, O(log n) average case (unbalanced)
     - AVL: Height ≤ 1.44 log n (strictest balance → fastest lookups)
     - Red-Black: Height ≤ 2 log n (looser balance but still O(log n) guaranteed)
     - B-Tree: Height = O(log_b n) where b is branching factor (can be very shallow with large b)
  
  (d) Insertion/deletion trade-offs:
     - BST: O(h) where h can be O(n), simple but unreliable
     - AVL: More rotations required (up to O(log n) rotations per operation) but maintains strict balance
     - Red-Black: Fewer rotations (at most 3 for insertion, constant amortized for deletion), better for write-heavy workloads
     - B-Tree: Node splits/merges minimize disk I/O but require shifting keys within nodes
  
  (e) Real-world use cases:
     - BST: Educational purposes, or when data is known to be randomly distributed
     - AVL: Read-heavy applications where lookup speed is critical (e.g., in-memory databases, dictionaries)
     - Red-Black: Language standard libraries (C++ std::map, Java TreeMap) where balance between reads and writes is needed
     - B-Trees: Databases and file systems (e.g., MySQL indexes, NTFS) where minimizing disk I/O is paramount - storing multiple keys per node reduces height and number of disk accesses
topics:
  - "Binary Search Trees"
  - "AVL Trees"
  - "Red-Black Trees"
  - "B-Trees"
  - "Balanced Trees"
  - "Data Structure Selection"
  - "Performance Trade-offs"
