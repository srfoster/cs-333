id: "ch3-merge-sort-analysis"
type: "short-answer"
chapter: 3
question: |
  **Analyze merge sort as a divide-and-conquer algorithm.**
  
  **Level 0** Discuss why divide-and-conquer is a powerful paradigm and where merge sort is used.
  
  **Level 1** For sample arrays, demonstrate merge sort's divide and merge steps. Give pseudocode.
  
  **Level 2** Implement merge sort in a language of your choice.
  
  **Level 3** Derive the recurrence T(n) = 2T(n/2) + O(n) and solve using the Master Theorem. Explain the Θ(n log n) complexity.

answer: |
  **Merge Sort:**
  Divide array in half, recursively sort each half, merge sorted halves in O(n) time.
  
  **Recurrence:** T(n) = 2T(n/2) + O(n)
  - Two subproblems of size n/2
  - O(n) to merge
  
  **Master Theorem:** a=2, b=2, f(n)=n
  - n^(log_b a) = n^1 = n
  - Case 2: T(n) = Θ(n log n)
  
  **Properties:**
  Stable, Θ(n log n) in all cases, O(n) extra space. Good for linked lists and external sorting.

topics:
  - "Divide and Conquer"
  - "Merge Sort"
  - "Master Theorem"
  - "Recurrence Relations"
